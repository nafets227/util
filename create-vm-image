#! /bin/bash
#
# Install a new Machine for ArchLinux
#
# (C) 2014 Stefan Schallenberg
#

##### Usage ##################################################################
function usage() {
    echo $1
    echo
    echo "Usage: "
    echo "    $0 <hostname [ <rootdev] "
    echo "     <hostname> gives the hostname"
    echo "     <rootdev>  points to the device node of the root device."
    echo "                It defaults to /dev/vg-sys/<hostname>-sys."
    echo "     [ -h ] Show help only. Does not execute anything."
    echo
    echo "$0 Aborted."
}

##### ltrim #####
function ltrim {
	if [ $# -ne 1 ] ; then
		# Empty String results in empty string
		return
	fi

	# remove leading blanks
	printf "%s\n" "${1#"${1%%[![:space:]]*}"}"
	}

		
##### Install to USB-Stick ###################################################
# based on info from
# http://www.zdnet.de/41559191/multiboot-ueber-usb-nur-ein-stick-fuer-windows-und-linux/2/
# http://phoenixlzx.github.io/MinoriWiki/page/archlinux-on-loopback/
# AUR package mkinitcpio-loop-subdir 0.0.1-1
function inst-arch_do_usb () {
	# Parameter
	#  1 - Hostname
	#  2 - Device of USB Stick (e.g. /dev/sdb)

	if [ $# -lt 2 ] ; then
		printf "Internal Error: expected 2 Parms\n"
		return 1
	fi

	if [ ${2/\/dev\/*/\/dev\/} != "/dev/" ] ; then # dev does not begin with "/dev/"
		printf "Error: Device must start with /dev/\n"
		return 1
	fi
	raw_dev=${2#/dev/}

	if [ ! -b /dev/$raw_dev ] ; then # Device does not exist
		printf "Device /dev/%s does not exist. Aborting.\n" "$raw_dev"
		return 1
	fi

	type=$(lsblk -o type --noheading /dev/$raw_dev | head -1)
	if [ $type != "disk" ] ; then	# No disk device
		printf "Device /dev/%s is no disk (type %s). Cowardly aborting.\n" \
			"$raw_dev" "$type"
		return 1
	fi

	if [ $(cat /sys/class/block/$raw_dev/removable) != "1" ] ; then 
		# no removable device
		printf "device %s is not removable. Cowardly Aborting.\n" "$raw_dev"
		return 1
	fi

	echo "About to install Arch Linux on USB ($1)"
	echo "Root-Device: $2"
	echo "Warning: MBR and data in /arch/boot of $2 will be DELETED!"
	read -p "Press Enter to Continue, use Ctrl-C to break."

	mount /dev/${raw_dev}1 /mnt
	if [ $? -ne 0 ] ; then return 1; fi
	test -d /mnt/arch || mkdir /mnt/arch  
	test -e /mnt/arch/grub && ( rm -rf /mnt/arch/grub || return 1 )  
	mkdir /mnt/arch/grub || return 1

	# create new Root device
	inst_dev=/mnt/arch/rootfs
	if [ ! -e $inst_dev ]  ; then
		inst_size=4095 	# max size on FAT32 is 4GB - 1 sect	
		printf "Creating Bootdevice %s (size=%s MB)\n" "$inst_dev" "$inst_size"
		fallocate -l ${inst_size}M $inst_dev
		if [ $? -ne 0 ] ; then
			printf "Falling back to dd since fallocate is not working.\n" >&2
			dd if=/dev/zero of=$inst_dev bs=1M count=$inst_size 
			if [ $? -ne 0 ] ; then return 1; fi
		fi
	else
		printf "Reusing existing Bootdevice %s and reformatting it\n" "$inst_dev"
		# delete superblock to avoid warning when creating the new filesystem
		dd if=/dev/zero of=/mnt/arch/rootfs bs=1k count=4 conv=notrunc
	fi
		
	mkfs.ext4 -O "^has_journal" /mnt/arch/rootfs
	if [ $? -ne 0 ] ; then
		printf "Error creating Filesystem\n"
		return 1;
	fi

	test -d /mnt.root || mkdir /mnt.root		
	mount /mnt/arch/rootfs /mnt.root
	if [ $? -ne 0 ] ; then
		printf "Error mounting /mnt/arch/rootfs on /mnt.root\n"
		return 1
	fi

	mkdir -p /mnt.root/boot/grub2/grub	
	mount --bind /mnt/arch/grub /mnt.root/boot/grub2/grub
	if [ $? -ne 0 ] ; then
		printf "Error mounting /mnt/arch/boot\n"
		return 1
	fi
	
	#@TODO: gather UUID of USB from runnung system
	#@TODO: check why modprobe.conf does not include hook "loop"
	#@TODO: include vfat driver in initcpio
	mkdir -p /mnt.root/etc/grub.d
	cat >/mnt.root/etc/grub.d/10_linuxusb_nafetsde <<-"EOF"
		cat <<-"EOF_LINUXUSB"
			menuentry 'Arch Linux USB' --class arch --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-usb' {
				load_video
				set gfxpayload=keep
				insmod gzio
				insmod ext2
				search --no-floppy --fs-uuid --set=usbroot 56D1-E22B
				loopback loop ($usbroot)/arch/rootfs
				echo	'Loading Linux linux ...'
				linux	(loop)/boot/vmlinuz-linux root=/dev/disk/by-uuid/56D1-E22B@arch/rootfs rw quiet
				echo	'Loading initial ramdisk ...'
				initrd  (loop)/boot/initramfs-linux.img
			}		
			EOF_LINUXUSB
		EOF
	chmod +x /mnt.root/etc/grub.d/10_linuxusb_nafetsde
	
	inst-arch_ondir "$1" "/mnt.root" "$3" "usb" "/dev/$raw_dev"

    umount --recursive /mnt.root
    rmdir /mnt.root
    umount --recursive /mnt
}


##### main ####################################################################
. $(dirname $BASH_SOURCE)/install-functions.sh
if [ $? -ne 0 ] ; then 
	printf "install-functions.sh not found. Aborting.\n"
	exit 1
fi

. $(dirname $BASH_SOURCE)/inst-arch-functions.sh
if [ $? -ne 0 ] ; then 
	printf "inst-arch-functions.sh not found. Aborting.\n"
	exit 1
fi

. $(dirname $BASH_SOURCE)/inst-coreos-functions.sh
if [ $? -ne 0 ] ; then 
	printf "inst-coreos-functions.sh not found. Aborting.\n"
	exit 1
fi


if [ $# -lt 1 ]; then
	usage "Got $# arguments, minimum 1 expected"
else
	#detect xen special handling
	case "$1" in 
		*xen1* | *Xen1* )
			extrapkg="grub efibootmgr"
			bootdev="/dev/disk/by-partlabel/xen1-boot"
			rootdev=${2:-/dev/disk/by-partlabel/xen1-sys}
			itype="kvm"
			mtype="xen"
			;;
		*xen2* | *Xen2* )
			extrapkg="grub efibootmgr"
			bootdev="/dev/disk/by-partlabel/xen2-boot"
			rootdev=${2:-/dev/disk/by-partlabel/xen2-sys}
			itype="kvm"
			mtype="xen"
			;;
		vKube | vKubeWrk* | vKubeEdge* )
			rootdev=${2:-/dev/vg-sys/$1-sys}
			mtype="coreos"
			;;
		vKube* )
			rootdev=${2:-/dev/vg-sys/$1-sys}
			mtype="coreos-ct"
			;;
		vKvm* )
			if [ ! -z "$2" ] ; then
				rootdev="$2"
			elif [ -b "/dev/vg-sys/$1-sys" ] ; then
				rootdev="/dev/vg-sys/$1-sys"
			else
				rootdev="/var/lib/libvirt/images/$1.raw"
			fi
			itype="${1//vKvm/}"
			if [ "$itype" != "Test" ] ; then
				itype="${itype//Test/}"
			fi
			mtype="kvm"
			;;
		usbArch )
			rootdev=$2 # no default
			extrapkg="mkinitcpio-addon-rootloop grub efibootmgr" # to speed up
			mtype="usb"
			;;
		* )
			rootdev=${2:-/dev/vg-sys/$1-sys}
			extrapkg=""
			bootdev=""
			mtype="arch"
	esac

	if [ "$mtype" != "kvm" ] && [ ! -b $rootdev ]; then
		usage "$rootdev is not a Blockdevice"
	elif [ "$mtype" == "coreos-ct" ]; then # Normal Core-OS machine
		inst-coreos_do $1 $rootdev
	elif [ "$mtype" == "coreos" ]; then # Normal Core-OS machine
		inst-arch_do_coreos $1 $rootdev
	elif [ "$mtype" == "xen" ]; then # Physical Arch machine
		inst-arch_do $1 $rootdev "$extrapkg" $bootdev 1 $itype
	elif [ "$mtype" == "arch" ]; then # Normal Arch Machine
		inst-arch_do $1 $rootdev "$extrapkg" $bootdev
	elif [ "$mtype" == "kvm" ]; then # KVM Arch Machine
		inst-arch_do_kvm "$1" "$rootdev" "$extrapkg" $itype
	elif [ "$mtype" == "usb" ] ; then # USB Stick
		inst-arch_do_usb "$1" "$rootdev" "$extrapkg"

	else # Unknown Machine Type
		usage "Internal Error: Invalid system type $mtype"
	fi
fi
